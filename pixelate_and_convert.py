import sys
import os
from PIL import Image

# Filtering function

def filter_dark_pixels(small_pixelated, grid_width, grid_height, max_pixels=150, threshold=10):
    pixels = []
    for y in range(grid_height):
        for x in range(grid_width):
            val = small_pixelated.getpixel((x, y))
            if isinstance(val, int) and val > 0:
                pixels.append((x, y))
    if len(pixels) > max_pixels:
        for x, y in pixels:
            val = small_pixelated.getpixel((x, y))
            if isinstance(val, int) and val <= threshold:
                small_pixelated.putpixel((x, y), 0)
    return small_pixelated


# Generate C struct for a single frame, using the filtering function

def generate_c_struct(pixel_data, grid_width, grid_height, c_output_path, struct_variable_name, frame_number):
    pixel_data = filter_dark_pixels(pixel_data, grid_width, grid_height)
    pixels = []
    
    for y in range(grid_height):
        for x in range(grid_width):
            brightness = pixel_data.getpixel((x, y))
            if brightness > 0:
                pixels.append({'x': x, 'y': y, 'brightness': brightness})

    # Build C code
    c_code = [
        '// Generated by the pixelator script.\n',
        '#include <stdint.h>\n',
        '// NOTE: Ensure these definitions match your project\'s settings.\n',
        f'#define ANIMATION_MAX_ACTIVE_PIXELS ({grid_width} * {grid_height})\n',
        f'#define ANIMATION_GRID_WIDTH {grid_width}\n',
        '\n',
        '// Macro to convert 2D coordinates to a 1D array index.\n',
        '#define ANIMATION_PIXEL_INDEX(y, x) ((y) * ANIMATION_GRID_WIDTH + (x))\n',
        '\n',
        '// The struct definition this data is based on.\n',
        'typedef struct {\n',
        '    uint8_t brightness_levels[ANIMATION_MAX_ACTIVE_PIXELS];\n',
        '    uint8_t frame_number; // Index of this frame in an animation\n',
        '    uint8_t num_pixels;\n',
        '} AnimationFrame;\n\n',
        f'AnimationFrame const {struct_variable_name}[1] = {{\n',
        '    {\n',
        f'        .frame_number = {frame_number},\n',
        f'        .num_pixels = {len(pixels)},\n',
        '        .brightness_levels = {\n'
    ]
    
    for p in pixels:
        c_code.append(f'            [ANIMATION_PIXEL_INDEX({p["y"]}, {p["x"]})] = {p["brightness"]},\n')
    
    c_code.extend([
        '        },\n',
        '    },\n',
        '};\n'
    ])

    # Save file
    output_dir = os.path.dirname(c_output_path)
    os.makedirs(output_dir, exist_ok=True)
    
    with open(c_output_path, 'w') as f:
        f.write("".join(c_code))
    
    print(f"Successfully saved C struct data to '{c_output_path}'")

# Process image function
# Center, convert to grayscale and pixelate

def process_image(input_path, output_path, grid_width=18, grid_height=11, cell_width=50, 
                  struct_variable_name="animation_frame", frame_number=0, return_pixelated=False):
    try:
        original_img = Image.open(input_path)
    except FileNotFoundError:
        print(f"Error: The file '{input_path}' was not found.")
        return
    except Exception as e:
        print(f"Error opening or processing image: {e}")
        return

    # Setup canvas
    cell_height = int(cell_width * 1.6)
    canvas_width = grid_width * cell_width
    canvas_height = grid_height * cell_height
    
    background = Image.new('L', (canvas_width, canvas_height), 0)
    print(f"Created a black canvas with {grid_width}:{grid_height} grid, each cell {cell_width}x{cell_height}.")

    # Process original image
    original_img = original_img.convert('L')
    original_width, original_height = original_img.size

    # Scale to fill canvas
    scale_factor = max(canvas_width / original_width, canvas_height / original_height)
    new_width = int(original_width * scale_factor)
    new_height = int(original_height * scale_factor)

    resized_img = original_img.resize((new_width, new_height), Image.Resampling.LANCZOS)
    
    paste_x = (canvas_width - new_width) // 2
    paste_y = (canvas_height - new_height) // 2
    
    background.paste(resized_img, (paste_x, paste_y))
    print("Centered and resized the original image onto the canvas (cropped to fill).")

    # Pixelate
    small_pixelated = background.resize((grid_width, grid_height), Image.Resampling.LANCZOS)
    print(f"Pixelated the image down to {grid_width}x{grid_height} pixels.")

    # Apply filtering to output image as well
    small_pixelated = filter_dark_pixels(small_pixelated, grid_width, grid_height)

    final_image = small_pixelated.resize((canvas_width, canvas_height), Image.Resampling.NEAREST)
    print("Scaled the pixelated image up for viewing.")

    # Save
    output_dir = "output_images"
    os.makedirs(output_dir, exist_ok=True)
    output_full_path = os.path.join(output_dir, os.path.basename(output_path))

    final_image.save(output_full_path)
    print(f"Successfully saved the processed image to '{output_full_path}'")

    if return_pixelated:
        return small_pixelated


def generate_c_struct_array(frame_data_list, grid_width, grid_height, c_output_path, struct_variable_name):
    """Generate a C struct array from multiple frame data."""
    c_code = [
        '// Generated by the pixelator script.\n',
        '#include <stdint.h>\n',
        '// NOTE: Ensure these definitions match your project\'s settings.\n',
        f'#define ANIMATION_MAX_ACTIVE_PIXELS ({grid_width} * {grid_height})\n',
        f'#define ANIMATION_GRID_WIDTH {grid_width}\n',
        '\n',
        '// Macro to convert 2D coordinates to a 1D array index.\n',
        '#define ANIMATION_PIXEL_INDEX(y, x) ((y) * ANIMATION_GRID_WIDTH + (x))\n',
        '\n',
        '// The struct definition this data is based on.\n',
        'typedef struct {\n',
        '    uint8_t brightness_levels[ANIMATION_MAX_ACTIVE_PIXELS];\n',
        '    uint8_t frame_number; // Index of this frame in an animation\n',
        '    uint8_t num_pixels;\n',
        '} AnimationFrame;\n\n',
        f'AnimationFrame const {struct_variable_name}[{len(frame_data_list)}] = {{\n'
    ]
    
    for small_pixelated, frame_number in frame_data_list:
        # Apply filtering to match output image
        small_pixelated = filter_dark_pixels(small_pixelated, grid_width, grid_height)
        # Gather pixel data
        pixels = []
        for y in range(grid_height):
            for x in range(grid_width):
                brightness = small_pixelated.getpixel((x, y))
                if brightness > 0:
                    pixels.append({'x': x, 'y': y, 'brightness': brightness})
        
        c_code.extend([
            '    {\n',
            f'        .frame_number = {frame_number},\n',
            f'        .num_pixels = {len(pixels)},\n',
            '        .brightness_levels = {\n'
        ])
        
        for p in pixels:
            c_code.append(f'            [ANIMATION_PIXEL_INDEX({p["y"]}, {p["x"]})] = {p["brightness"]},\n')
        
        c_code.extend([
            '        },\n',
            '    },\n'
        ])
    
    c_code.append('};\n')

    # Save file
    output_dir = os.path.dirname(c_output_path)
    os.makedirs(output_dir, exist_ok=True)
    with open(c_output_path, 'w') as f:
        f.write("".join(c_code))
    print(f"Successfully saved C struct array to '{c_output_path}'")


if __name__ == "__main__":
    if len(sys.argv) == 2 and os.path.isdir(sys.argv[1]):
        # Process directory of PNG files
        input_dir = sys.argv[1]
        output_dir = "output_images"
        os.makedirs(output_dir, exist_ok=True)
        frame_data_list = []
        grid_width = 18
        grid_height = 11
        
        filenames = sorted([f for f in os.listdir(input_dir) if f.lower().endswith(".png")])
        for i, filename in enumerate(filenames):
            input_file = os.path.join(input_dir, filename)
            output_file = os.path.join(output_dir, filename)
            print(f"Processing {input_file}...")
            small_pixelated = process_image(input_file, output_file, grid_width=grid_width, 
                                          grid_height=grid_height, frame_number=i, return_pixelated=True)
            if small_pixelated:
                frame_data_list.append((small_pixelated, i))
        
        # Generate C struct array
        if frame_data_list:
            generate_c_struct_array(
                frame_data_list,
                grid_width=grid_width,
                grid_height=grid_height,
                c_output_path="frames_as_c_code/tester.c",
                struct_variable_name="animation_frames"
            )
    elif len(sys.argv) == 4:
        # Process single file with frame number
        input_file = sys.argv[1]
        output_file = sys.argv[2]
        frame_number = int(sys.argv[3])
        process_image(input_file, output_file, frame_number=frame_number)
    elif len(sys.argv) == 3:
        input_file = sys.argv[1]
        output_file = sys.argv[2]
        process_image(input_file, output_file)
    else:
        print("Usage:")
        print("  python pixelate_and_convert.py <input_file> <output_file>")
        print("  python pixelate_and_convert.py <input_directory>")