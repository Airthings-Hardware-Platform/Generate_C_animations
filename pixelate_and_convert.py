import sys
import os
from PIL import Image

def generate_c_struct(pixel_data, grid_width, grid_height, c_output_path, struct_variable_name, frame_number):
    """
    Generates a C struct instance from pixelated image data.

    Args:
        pixel_data (Image.Image): A PIL Image object (in 'L' mode) of the pixelated data.
        grid_width (int): The width of the pixel grid.
        grid_height (int): The height of the pixel grid.
        c_output_path (str): The path to save the generated .c file.
        struct_variable_name (str): The name for the C array variable.
        frame_number (int): The frame number to embed in the struct.
    """
    pixels = []
    # Iterate through each pixel of the small image to get its brightness
    for y in range(grid_height):
        for x in range(grid_width):
            brightness = pixel_data.getpixel((x, y))
            # We only store pixels that are not completely black (brightness > 0)
            # to match the sparse format of the example C struct.
            if brightness > 0:
                # In C, it's common to index 2D arrays as row-major: y * width + x
                # The macro is ANIMATION_PIXEL_INDEX(y, x), so we use (y, x) order.
                pixels.append({'x': x, 'y': y, 'brightness': brightness})

    # Start building the C code string
    c_code = []
    
    # --- Header and Definitions ---
    c_code.append('// Generated by the pixelator script.\n')
    c_code.append('#include <stdint.h>\n')
    c_code.append('// NOTE: Ensure these definitions match your project\'s settings.\n')
    # Assuming the grid size is the max number of pixels
    c_code.append(f'#define ANIMATION_MAX_ACTIVE_PIXELS ({grid_width} * {grid_height})\n')
    c_code.append(f'#define ANIMATION_GRID_WIDTH {grid_width}\n')
    c_code.append('\n')
    c_code.append('// Macro to convert 2D coordinates to a 1D array index.\n')
    c_code.append('#define ANIMATION_PIXEL_INDEX(y, x) ((y) * ANIMATION_GRID_WIDTH + (x))\n')
    c_code.append('\n')
    c_code.append('// The struct definition this data is based on.\n')
    c_code.append('typedef struct {\n')
    c_code.append('    uint8_t brightness_levels[ANIMATION_MAX_ACTIVE_PIXELS];\n')
    c_code.append('    uint8_t frame_number; // Index of this frame in an animation\n')
    c_code.append('    uint8_t num_pixels;\n')
    c_code.append('} AnimationFrame;\n\n')

    # --- Struct Instance ---
    # The [1] creates a single-element array, which can be easily combined with other frames.
    c_code.append(f'AnimationFrame const {struct_variable_name}[1] = {{\n')
    c_code.append('    {\n')
    c_code.append(f'        .frame_number = {frame_number},\n')
    c_code.append(f'        .num_pixels = {len(pixels)},\n')
    c_code.append('        .brightness_levels = {\n')

    for p in pixels:
        c_code.append(f'            [ANIMATION_PIXEL_INDEX({p["y"]}, {p["x"]})] = {p["brightness"]},\n')

    c_code.append('        },\n')
    c_code.append('    },\n')
    c_code.append('};\n')

    # --- Save the file ---
    output_dir = os.path.dirname(c_output_path)
    os.makedirs(output_dir, exist_ok=True)
    
    with open(c_output_path, 'w') as f:
        f.write("".join(c_code))
    
    print(f"Successfully saved C struct data to '{c_output_path}'")


def process_image(input_path, output_path, grid_width=18, grid_height=11, cell_width=50, 
                  struct_variable_name="animation_frame", frame_number=0, return_pixelated=False):
    """
    Centers an image, converts it to grayscale, pixelates it, saves the image,
    and generates a corresponding C struct.

    Args:
        input_path (str): The path to the input image file.
        output_path (str): The path to save the processed image file.
        grid_width (int): The number of horizontal cells in the final grid.
        grid_height (int): The number of vertical cells in the final grid.
        cell_width (int): The width of each cell in pixels (height will be 1.8x this).
        struct_variable_name (str): The name of the C array variable to be generated.
        frame_number (int): The frame number for the C struct.
        return_pixelated (bool): Whether to return the pixelated image.
    """
    try:
        original_img = Image.open(input_path)
    except FileNotFoundError:
        print(f"Error: The file '{input_path}' was not found.")
        return
    except Exception as e:
        print(f"Error opening or processing image: {e}")
        return

    cell_height = int(cell_width * 1.8)
    canvas_width = grid_width * cell_width
    canvas_height = grid_height * cell_height
    target_aspect = canvas_width / canvas_height

    background = Image.new('L', (canvas_width, canvas_height), 0) # Black background
    print(f"Created a black canvas with {grid_width}:{grid_height} grid, each cell {cell_width}x{cell_height}.")

    original_img = original_img.convert('L')
    original_width, original_height = original_img.size
    original_aspect = original_width / original_height

    # Determine scaling to fill the canvas (crop longer side)
    scale_factor = max(canvas_width / original_width, canvas_height / original_height)
    new_width = int(original_width * scale_factor)
    new_height = int(original_height * scale_factor)

    resample_lanczos = Image.Resampling.LANCZOS
    resample_nearest = Image.Resampling.NEAREST

    resized_img = original_img.resize((new_width, new_height), resample_lanczos)
    
    paste_x = (canvas_width - new_width) // 2
    paste_y = (canvas_height - new_height) // 2
    
    # Paste with cropping (crop the overflowing part)
    background.paste(resized_img, (paste_x, paste_y))
    print("Centered and resized the original image onto the canvas (cropped to fill).")

    # Invert colors so that white in the original image is bright (255) and black is dark (0)
    # The background is currently black (0), which will be correctly ignored by the C struct generator.
    # If your original image has a white background, it will become bright pixels.
    # from PIL import ImageOps
    # background = ImageOps.invert(background) # Uncomment this if your source image is black-on-white
    
    small_pixelated = background.resize((grid_width, grid_height), resample_lanczos)
    print(f"Pixelated the image down to {grid_width}x{grid_height} pixels.")

    final_image = small_pixelated.resize((canvas_width, canvas_height), resample_nearest)
    print("Scaled the pixelated image up for viewing.")

    output_dir = "output_images"
    os.makedirs(output_dir, exist_ok=True)
    output_full_path = os.path.join(output_dir, os.path.basename(output_path))

    final_image.save(output_full_path)
    print(f"Successfully saved the processed image to '{output_full_path}'")

    if return_pixelated:
        return small_pixelated


def generate_c_struct_array(frame_data_list, grid_width, grid_height, c_output_path, struct_variable_name):
    c_code = []
    # --- Header and Definitions ---
    c_code.append('// Generated by the pixelator script.\n')
    c_code.append('#include <stdint.h>\n')
    c_code.append('// NOTE: Ensure these definitions match your project\'s settings.\n')
    c_code.append(f'#define ANIMATION_MAX_ACTIVE_PIXELS ({grid_width} * {grid_height})\n')
    c_code.append(f'#define ANIMATION_GRID_WIDTH {grid_width}\n')
    c_code.append('\n')
    c_code.append('// Macro to convert 2D coordinates to a 1D array index.\n')
    c_code.append('#define ANIMATION_PIXEL_INDEX(y, x) ((y) * ANIMATION_GRID_WIDTH + (x))\n')
    c_code.append('\n')
    c_code.append('// The struct definition this data is based on.\n')
    c_code.append('typedef struct {\n')
    c_code.append('    uint8_t brightness_levels[ANIMATION_MAX_ACTIVE_PIXELS];\n')
    c_code.append('    uint8_t frame_number; // Index of this frame in an animation\n')
    c_code.append('    uint8_t num_pixels;\n')
    c_code.append('} AnimationFrame;\n\n')

    # --- Struct Array ---
    c_code.append(f'AnimationFrame const {struct_variable_name}[{len(frame_data_list)}] = {{\n')
    for small_pixelated, frame_number in frame_data_list:
        # Gather pixel data
        pixels = []
        for y in range(grid_height):
            for x in range(grid_width):
                brightness = small_pixelated.getpixel((x, y))
                if brightness > 0:
                    pixels.append({'x': x, 'y': y, 'brightness': brightness})
        c_code.append('    {\n')
        c_code.append(f'        .frame_number = {frame_number},\n')
        c_code.append(f'        .num_pixels = {len(pixels)},\n')
        c_code.append('        .brightness_levels = {\n')
        for p in pixels:
            c_code.append(f'            [ANIMATION_PIXEL_INDEX({p["y"]}, {p["x"]})] = {p["brightness"]},\n')
        c_code.append('        },\n')
        c_code.append('    },\n')
    c_code.append('};\n')

    # --- Save the file ---
    output_dir = os.path.dirname(c_output_path)
    os.makedirs(output_dir, exist_ok=True)
    with open(c_output_path, 'w') as f:
        f.write("".join(c_code))
    print(f"Successfully saved C struct array to '{c_output_path}'")


if __name__ == "__main__":
    # If a directory is provided, process all .png files in it
    if len(sys.argv) == 2 and os.path.isdir(sys.argv[1]):
        input_dir = sys.argv[1]
        output_dir = "output_images"
        os.makedirs(output_dir, exist_ok=True)
        frame_data_list = []
        grid_width = 18
        grid_height = 11
        filenames = sorted([f for f in os.listdir(input_dir) if f.lower().endswith(".png")])
        for i, filename in enumerate(filenames):
            input_file = os.path.join(input_dir, filename)
            output_file = os.path.join(output_dir, filename)
            print(f"Processing {input_file}...")
            small_pixelated = process_image(input_file, output_file, grid_width=grid_width, grid_height=grid_height, frame_number=i, return_pixelated=True)
            if small_pixelated:
                frame_data_list.append((small_pixelated, i))
        
        # After all frames are processed, write them to a single C file
        if frame_data_list:
            generate_c_struct_array(
                frame_data_list,
                grid_width=grid_width,
                grid_height=grid_height,
                c_output_path="frames_as_c_code/all_frames.c",
                struct_variable_name="animation_frames"
            )
    elif len(sys.argv) == 4:
        input_file = sys.argv[1]
        output_file = sys.argv[2]
        frame_number = int(sys.argv[3])
        process_image(input_file, output_file, frame_number=frame_number)
    elif len(sys.argv) == 3:
        input_file = sys.argv[1]
        output_file = sys.argv[2]
        process_image(input_file, output_file)
    else:
        print("Usage:")
        print("  python pixelate_and_convert.py <input_file> <output_file>")
        print("  python pixelate_and_convert.py <input_directory>")